100,105c100,105
<     'POSTGRES_ADMIN_PASSWORD', 'secret',
<     'POSTGRES_SERVER',   '127.0.0.1',
<     'POSTGRES_PORT',     5432,
<     'POSTGRES_DATABASE', 'dvndb',
<     'POSTGRES_USER',     'dvnapp',
<     'POSTGRES_PASSWORD', 'secret',
---
>     'POSTGRES_ADMIN_PASSWORD', $ENV{'POSTGRES_ADMIN_PASSWORD'},
>     'POSTGRES_SERVER',   $ENV{'POSTGRES_SERVER'},
>     'POSTGRES_PORT',     $ENV{'POSTGRES_PORT'},
>     'POSTGRES_DATABASE', $ENV{'POSTGRES_DATABASE'},
>     'POSTGRES_USER',     $ENV{'POSTGRES_USER'},
>     'POSTGRES_PASSWORD', $ENV{'POSTGRES_PASSWORD'},
107c107
<     'SOLR_LOCATION',     'LOCAL',
---
>     'SOLR_LOCATION',     'solr:8983',
1370,1423c1370
<     if ($psql_exec_path eq "" || system( $psql_admin_exec . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U " . $POSTGRES_ADMIN_USER . " -d postgres -c 'SELECT * FROM pg_roles' > /dev/null 2>&1" ) ) 
<     {
< 	# No, we can't. :(
< 	if ($pg_local_connection || $noninteractive) 
< 	{
< 	    # If Postgres is running locally, this is a fatal condition. 
< 	    # We'll give them some (potentially) helpful pointers and exit.
< 
< 	    print "(Tried executing: " . $psql_admin_exec . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U " . $POSTGRES_ADMIN_USER . " -d postgres -c 'SELECT * FROM pg_roles' > /dev/null 2>&1) \n";
< 	    print "Nope, I haven't been able to connect to the local instance of PostgresQL as the admin user.\n";
< 	    print "\nIs postgresql running? \n";
< 	    print "   On a RedHat-like system, you can check the status of the daemon with\n\n";
< 	    print "      service postgresql start\n\n";
< 	    print "   On MacOSX, use Applications -> PostgresQL -> Start Server.\n";
< 	    print "   (or, if there's no \"Start Server\" item in your PostgresQL folder, \n";
< 	    print "   simply restart your MacOSX system!)\n";
< 	    print "\nAlso, please make sure that the daemon is listening to network connections!\n";
< 	    print "   - at least on the localhost interface. (See \"Installing Postgres\" section\n";
< 	    print "   of the installation manual).\n";
< 	    print "\nFinally, did you supply the correct admin password?\n";
< 	    print "   Don't know the admin password for your Postgres installation?\n";
< 	    print "   - then simply set the access level to \"trust\" temporarily (for localhost only!)\n";
< 	    print "   in your pg_hba.conf file. Again, please consult the \n";
< 	    print "   installation manual).\n";
< 	    exit 1;
< 	}
< 	else 
< 	{
< 	    # If we are configuring the Dataverse instance to use a Postgres server 
< 	    # running on a remote host, it is possible to configure the database
< 	    # without opening remote access for the admin user. They will simply 
< 	    # have to run this script in the "postgres-only" mode on that server, locally, 
< 	    # then resume the installation here: 
< 	    print "(Tried executing: " . $psql_admin_exec . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U " . $POSTGRES_ADMIN_USER . " -d postgres -c 'SELECT * FROM pg_roles' > /dev/null 2>&1)\n\n";
< 	    print "Haven't been able to connect to the remote Postgres server as the admin user.\n";
< 	    print "(Or you simply don't have psql installed on this server)\n";
< 	    print "It IS possible to configure a database for your Dataverse on a remote server,\n";
< 	    print "without having admin access to that remote Postgres installation.\n\n";
< 	    print "In order to do that, please copy the installer (the entire package) to the server\n";
< 	    print "where PostgresQL is running and run the installer with the \"--pg_only\" option:\n\n";
< 	    print "   ./install --pg_only\n\n";
< 
< 	    print "Press any key to continue the installation process once that has been\n";
< 	    print "done. Or press ctrl-C to exit the installer.\n\n";
< 	    
< 	    system "stty cbreak </dev/tty >/dev/tty 2>&1";
< 	    my $key = getc(STDIN);
< 	    system "stty -cbreak </dev/tty >/dev/tty 2>&1";
< 	    print "\n";
< 	}
<     }
<     else 
<     {
< 	print "Yes, we can!\n";
---
> # No need to connect as admin, we are ensured that the db exist as the postgresql container ensures it
1425,1540d1371
< 	# ok, we can proceed with configuring things...
< 
< 	print "\nConfiguring Postgres Database:\n";
< 
< 	# 4c. CHECK IF THIS DB ALREADY EXISTS:
<     
< 	my $psql_command_dbcheck =
< 	    $psql_admin_exec . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U " . $POSTGRES_ADMIN_USER . " -c '' -d " . $CONFIG_DEFAULTS{'POSTGRES_DATABASE'} . ">/dev/null 2>&1";
< 
< 	if ( ( my $exitcode = system($psql_command_dbcheck) ) == 0 ) 
< 	{    
< 	    if ($force) 
< 	    {
< 		print "WARNING! Database "
< 		    . $CONFIG_DEFAULTS{'POSTGRES_DATABASE'}
< 		. " already exists but --force given... continuing.\n";
< 	    } 
< 	    else 
< 	    {
< 		print "WARNING! Database " . $CONFIG_DEFAULTS{'POSTGRES_DATABASE'} . " already exists!\n";
< 
< 		if ($noninteractive)
< 		{
< 		    exit 1;
< 		}
< 		else
< 		{
< 		    print "\nPress any key to continue, or ctrl-C to exit the installer...\n\n";
<         
< 		    system "stty cbreak </dev/tty >/dev/tty 2>&1";
< 		    my $key = getc(STDIN);
< 		    system "stty -cbreak </dev/tty >/dev/tty 2>&1";
< 		    print "\n";
< 
< 		}
< 	    }
< 	}
< 
< 	# 3e. CHECK IF THIS USER ALREADY EXISTS:
<     
< 	my $psql_command_rolecheck =
< 	    $psql_exec_path . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -c '' -d postgres " . $CONFIG_DEFAULTS{'POSTGRES_USER'} . " >/dev/null 2>&1";
< 	my $exitcode; 
< 
< 	if ( ( $exitcode = system($psql_command_rolecheck) ) == 0 ) 
< 	{
< 	    print "User (role) " . $CONFIG_DEFAULTS{'POSTGRES_USER'} . " already exists;\n";
< 	    print "Proceeding.";
< 	}
< 	else 
< 	{
< 	    # 3f. CREATE DVN DB USER:
< 	    
< 	    print "\nCreating Postgres user (role) for the DVN:\n";
<     
< 	    open TMPCMD, ">/tmp/pgcmd.$$.tmp";
< 
< 	    # with md5-encrypted password:
< 	    my $pg_password_md5 =
< 		&create_pg_hash( $CONFIG_DEFAULTS{'POSTGRES_USER'}, $CONFIG_DEFAULTS{'POSTGRES_PASSWORD'} );
< 	    my $sql_command =
< 		"CREATE ROLE \""
< 		. $CONFIG_DEFAULTS{'POSTGRES_USER'}
< 	    . "\" PASSWORD 'md5"
< 		. $pg_password_md5
< 		. "' NOSUPERUSER CREATEDB CREATEROLE INHERIT LOGIN";
< 
< 	    print TMPCMD $sql_command;
< 	    close TMPCMD;
<         
< 	    my $psql_commandline = $psql_admin_exec . "/psql -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U " . $POSTGRES_ADMIN_USER . " -d postgres -f /tmp/pgcmd.$$.tmp >/dev/null 2>&1";
< 
< 	    my $out      = qx($psql_commandline 2>&1);
< 	    $exitcode = $?;
< 	    unless ( $exitcode == 0 ) 
< 	    {
< 		print STDERR "Could not create the DVN Postgres user role!\n";
< 		print STDERR "(SQL: " . $sql_command . ")\n";
< 		print STDERR "(psql exit code: " . $exitcode . ")\n";
< 		print STDERR "(STDERR and STDOUT was: " . $out . ")\n";
< 		exit 1;
< 	    }
< 
< 	    unlink "/tmp/pgcmd.$$.tmp";
< 	    print "done.\n";
< 	}
<     
< 	# 3g. CREATE DVN DB:
<     
< 	print "\nCreating Postgres database:\n";
<     
< 	my $psql_command =
< 	    $psql_exec_path
< 	    . "/createdb -h " . $CONFIG_DEFAULTS{'POSTGRES_SERVER'} . " -p " . $CONFIG_DEFAULTS{'POSTGRES_PORT'} . " -U $CONFIG_DEFAULTS{'POSTGRES_USER'} "
< 	    . $CONFIG_DEFAULTS{'POSTGRES_DATABASE'} . " --owner="
< 	    . $CONFIG_DEFAULTS{'POSTGRES_USER'};
< 
< 	my $out = qx($psql_command 2>&1);
<         $exitcode = $?;
< 	unless ( $exitcode == 0 ) 
< 	{
< 	    print STDERR "Could not create Postgres database for the Dataverse app!\n";
< 	    print STDERR "(command: " . $psql_command . ")\n";
< 	    print STDERR "(psql exit code: " . $exitcode . ")\n";
< 	    print STDERR "(STDOUT and STDERR: " . $out . ")\n";
< 	    if ($force) 
< 	    {
< 		print STDERR "\ncalled with --force, continuing\n";
< 	    }
< 	    else 
< 	    {
< 		print STDERR "\naborting the installation (sorry!)\n\n";
< 		exit 1;
< 	    }
< 	}
<     }
